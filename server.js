const express = require('express');
const helmet = require('helmet');
const compression = require('compression');
const cors = require('cors');
const cron = require('node-cron');
const moment = require('moment-timezone');
const fs = require('fs');

const { fetchAndSaveBundles } = require('./services/fetchBundles');
const { updateBundlesWithDetails, checkAndResumeUpdate, loadStorageDataWithRetry } = require('./services/updateBundles');
const { storageSyncManager } = require('./services/storageSync');
const updateController = require('./services/updateController'); // Importa para ativar auto-resume
const routes = require('./routes');
const { requestLogger, corsOptions } = require('./middleware/security');
const { healthCheck, errorHandler, notFoundHandler } = require('./middleware/monitoring');
const { publicRateLimit } = require('./middleware/auth');

const app = express();

app.set('trust proxy', 1);

app.use(helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'"],
            scriptSrc: ["'self'"],
            imgSrc: ["'self'", "data:", "https:"],
        },
    },
    hsts: {
        maxAge: 31536000,
        includeSubDomains: true,
        preload: true
    }
}));

app.use(compression());
app.use(cors(corsOptions));
app.use(express.json({ limit: '10mb' }));
app.use(requestLogger);
app.use(publicRateLimit);

app.get('/health', healthCheck);
app.use('/', routes);
app.use(notFoundHandler);
app.use(errorHandler);

const LAST_CHECK_FILE = 'last_check.json';
const BUNDLES_FILE = 'bundles.json';
const BUNDLES_DETAILED_FILE = 'bundleDetailed.json';
const TIMEZONE = process.env.TIMEZONE || 'America/Sao_Paulo';

// Configura√ß√£o de hor√°rios para execu√ß√£o autom√°tica
const STEAM_UPDATE_SCHEDULE = {
    // Modo otimizado: apenas nos dias que a Steam atualiza (padr√£o)
    OPTIMIZED: '0 3 * * 3,5', // 3h da manh√£ nas quartas e sextas (ap√≥s atualiza√ß√µes da Steam)
    
    // Modo di√°rio: todas as madrugadas (se necess√°rio maior frequ√™ncia)
    DAILY: '0 3 * * *', // 3h da manh√£ todos os dias
    
    // Modo conservador: apenas uma vez por semana
    WEEKLY: '0 3 * * 3' // 3h da manh√£ apenas nas quartas
};

// Escolha o modo baseado na vari√°vel de ambiente
const scheduleMode = process.env.UPDATE_SCHEDULE_MODE || 'OPTIMIZED';
const cronExpression = STEAM_UPDATE_SCHEDULE[scheduleMode] || STEAM_UPDATE_SCHEDULE.OPTIMIZED;

// Fun√ß√µes auxiliares para status e agendamento (agora com acesso √†s constantes)
function getNextScheduledUpdate() {
    const now = moment().tz(TIMEZONE);
    const nextRun = getNextCronExecution(cronExpression, now);
    return nextRun.format('DD/MM/YYYY HH:mm:ss');
}

function getNextCronExecution(cronExpr, fromTime) {
    const [minute, hour, day, month, dayOfWeek] = cronExpr.split(' ');
    let next = fromTime.clone().add(1, 'day').startOf('day').hour(parseInt(hour)).minute(parseInt(minute));
    
    if (dayOfWeek !== '*') {
        const targetDays = dayOfWeek.split(',').map(d => parseInt(d));
        while (!targetDays.includes(next.day())) {
            next.add(1, 'day');
        }
        next.hour(parseInt(hour)).minute(parseInt(minute));
    }
    
    return next;
}

// Torna as fun√ß√µes dispon√≠veis globalmente para uso em routes.js
global.getNextScheduledUpdate = getNextScheduledUpdate;
global.getNextCronExecution = getNextCronExecution;

const checkLastVerification = async () => {
    console.log('üîç Verificando status dos dados no Storage API...');
    
    try {
        // Testa conectividade com Storage API
        const connectivity = await storageSyncManager.testConnection();
        if (!connectivity.success) {
            console.log('‚ùå Storage API indispon√≠vel - executando coleta completa...');
            fetchAndSaveBundles();
            return;
        }
        
        console.log('‚úÖ Storage API conectado');
        
        // Verifica dados b√°sicos (bundles) com retry autom√°tico
        let bundlesData = null;
        try {
            console.log('üì° Verificando bundles b√°sicos com retry...');
            bundlesData = await loadStorageDataWithRetry('bundles', 3);
        } catch (error) {
            console.log('‚ö†Ô∏è Erro ao buscar dados b√°sicos ap√≥s retry:', error.message);
        }
        
        // Verifica dados detalhados (bundlesDetailed) com retry autom√°tico
        let detailedData = null;
        try {
            console.log('üì° Verificando bundles detalhados com retry...');
            detailedData = await loadStorageDataWithRetry('bundlesDetailed', 3);
        } catch (error) {
            console.log('‚ö†Ô∏è Erro ao buscar dados detalhados ap√≥s retry:', error.message);
        }
        
        const hasBundles = bundlesData && bundlesData.bundles && bundlesData.bundles.length > 0;
        const hasDetailed = detailedData && detailedData.bundles && detailedData.bundles.length > 0;
        
        console.log(`üìã Bundles b√°sicos: ${hasBundles ? `‚úÖ ${bundlesData.bundles.length} registros` : '‚ùå N√£o encontrados'}`);
        console.log(`üìÑ Bundles detalhados: ${hasDetailed ? `‚úÖ ${detailedData.bundles.length} registros` : '‚ùå N√£o encontrados'}`);
        
        // --- NOVA L√ìGICA DE VERIFICA√á√ÉO COM STORAGE API ---
        if (!hasBundles && !hasDetailed) {
            console.log('üö® Ambas as tabelas vazias/ausentes - iniciando coleta completa do in√≠cio...');
            fetchAndSaveBundles();
            return;
        }
        
        if (hasBundles && !hasDetailed) {
            console.log('üîç Bundles b√°sicos existem, mas detalhados n√£o. Verificando integridade...');
            
            // Verifica se os dados b√°sicos t√™m estrutura v√°lida
            const hasValidStructure = bundlesData.bundles.every(bundle => 
                bundle.Link && typeof bundle.Link === 'string' && bundle.Link.includes('/bundle/')
            );
            
            if (!hasValidStructure) {
                console.log('‚ö†Ô∏è Dados b√°sicos no Storage t√™m estrutura inv√°lida - reiniciando coleta completa...');
                fetchAndSaveBundles();
                return;
            }
            
            console.log(`‚úÖ Dados b√°sicos √≠ntegros (${bundlesData.bundles.length} bundles)`);
            console.log('üöÄ Dados detalhados ausentes - iniciando apenas atualiza√ß√£o detalhada...');
            
            // Executa apenas a atualiza√ß√£o detalhada via updateController
            setTimeout(() => {
                updateController.executeControlledUpdate(
                    () => updateBundlesWithDetails('brazilian'), 
                    'missing-detailed-data'
                ).catch(error => {
                    console.error('‚ùå Erro ao executar atualiza√ß√£o detalhada:', error.message);
                });
            }, 2000);
            return;
        }
        
        if (!hasBundles && hasDetailed) {
            console.log('‚ö†Ô∏è Dados detalhados existem mas b√°sicos n√£o - situa√ß√£o inconsistente');
            console.log('üö® Reiniciando coleta completa para garantir consist√™ncia...');
            fetchAndSaveBundles();
            return;
        }
        
        // Se ambos existem, verifica se est√£o atualizados
        if (hasBundles && hasDetailed) {
            console.log('‚úÖ Ambos os conjuntos de dados existem - verificando atualiza√ß√£o...');
            
            // Verifica timestamp da √∫ltima atualiza√ß√£o
            const lastUpdateTimestamp = bundlesData.metadata?.last_update || detailedData.metadata?.last_update;
            
            if (lastUpdateTimestamp) {
                const lastUpdate = moment.tz(lastUpdateTimestamp, TIMEZONE);
                const now = moment().tz(TIMEZONE);
                const hoursSinceLastUpdate = now.diff(lastUpdate, 'hours');
                
                console.log(`‚è∞ √öltima atualiza√ß√£o: ${lastUpdate.format('DD/MM/YYYY HH:mm:ss')} (${hoursSinceLastUpdate}h atr√°s)`);
                
                // Determina se precisa atualizar baseado no modo e hor√°rio
                const needsUpdate = shouldUpdateNow(lastUpdate, now, scheduleMode);
                
                if (needsUpdate.shouldUpdate) {
                    console.log(`üîÑ ${needsUpdate.reason} - iniciando atualiza√ß√£o...`);
                    fetchAndSaveBundles();
                } else {
                    console.log(`‚úÖ ${needsUpdate.reason}`);
                    console.log(`üìÖ Pr√≥xima atualiza√ß√£o agendada: ${getNextScheduledUpdate()}`);
                    
                    // Verifica se dados est√£o completos
                    const isComplete = detailedData.metadata?.isComplete || detailedData.isComplete;
                    if (!isComplete) {
                        console.log('‚ö†Ô∏è Dados detalhados incompletos detectados - verificando recupera√ß√£o...');
                        setTimeout(() => {
                            checkAndResumeUpdate().catch(error => {
                                console.error('‚ùå Erro ao verificar recupera√ß√£o:', error.message);
                            });
                        }, 1000);
                    }
                }
            } else {
                console.log('üìù Timestamp de atualiza√ß√£o n√£o encontrado - iniciando verifica√ß√£o inicial...');
                fetchAndSaveBundles();
            }
        }
        
    } catch (error) {
        console.error('‚ùå Erro durante verifica√ß√£o do Storage API:', error.message);
        console.log('üîÑ Fallback: verificando arquivos locais...');
        
        // Fallback para verifica√ß√£o local se Storage API falhar completamente
        checkLastVerificationLocal();
    }
};

// Fun√ß√£o para determinar se deve atualizar agora
function shouldUpdateNow(lastCheck, now, mode) {
    const hoursSince = now.diff(lastCheck, 'hours');
    const daysSince = now.diff(lastCheck, 'days');
    
    // Se passou mais de 7 dias, sempre atualiza independente do modo
    if (daysSince >= 7) {
        return { shouldUpdate: true, reason: 'Mais de 7 dias desde a √∫ltima verifica√ß√£o' };
    }
    
    // Se passou mais de 3 dias e n√£o √© modo conservador, atualiza
    if (daysSince >= 3 && mode !== 'WEEKLY') {
        return { shouldUpdate: true, reason: 'Mais de 3 dias desde a √∫ltima verifica√ß√£o' };
    }
    
    // Se passou mais de 24h e √© modo di√°rio, atualiza
    if (hoursSince >= 24 && mode === 'DAILY') {
        return { shouldUpdate: true, reason: 'Modo di√°rio: mais de 24h desde a √∫ltima verifica√ß√£o' };
    }
    
    // Se √© primeira execu√ß√£o do dia ap√≥s um dia de atualiza√ß√£o da Steam
    const today = now.day(); // 0=Dom, 1=Seg, 2=Ter, 3=Qua, 4=Qui, 5=Sex, 6=S√°b
    const yesterday = now.clone().subtract(1, 'day').day();
    
    if ((today === 3 || today === 5) && hoursSince >= 12) { // Qua ou Sex, e passou 12h
        const lastWasBeforeSteamUpdate = lastCheck.day() !== today;
        if (lastWasBeforeSteamUpdate) {
            return { shouldUpdate: true, reason: `Dia p√≥s-atualiza√ß√£o da Steam (${today === 3 ? 'Quarta' : 'Sexta'})` };
        }
    }
    
    return { 
        shouldUpdate: false, 
        reason: `Dados atualizados - pr√≥xima verifica√ß√£o conforme agendamento (${mode})` 
    };
}

// Fun√ß√£o de fallback para verifica√ß√£o local (se Storage API falhar)
const checkLastVerificationLocal = () => {
    console.log('üîç [FALLBACK] Verificando arquivos locais...');
    const bundlesExists = fs.existsSync(BUNDLES_FILE);
    const bundlesDetailedExists = fs.existsSync(BUNDLES_DETAILED_FILE);
    console.log(`üìã bundles.json: ${bundlesExists ? '‚úÖ Existe' : '‚ùå N√£o encontrado'}`);
    console.log(`üìÑ bundleDetailed.json: ${bundlesDetailedExists ? '‚úÖ Existe' : '‚ùå N√£o encontrado'}`);
    
    if (!bundlesExists && !bundlesDetailedExists) {
        console.log('üö® [FALLBACK] Ambos os arquivos ausentes - iniciando coleta completa...');
        fetchAndSaveBundles();
        return;
    }
    
    if (bundlesExists && !bundlesDetailedExists) {
        console.log('üîç [FALLBACK] Apenas bundles.json existe - iniciando atualiza√ß√£o detalhada...');
        setTimeout(() => {
            updateController.executeControlledUpdate(
                () => updateBundlesWithDetails('brazilian'), 
                'fallback-missing-detailed'
            ).catch(error => {
                console.error('‚ùå Erro ao executar atualiza√ß√£o detalhada:', error.message);
            });
        }, 2000);
        return;
    }
    
    if (bundlesExists && bundlesDetailedExists) {
        console.log('‚úÖ [FALLBACK] Ambos os arquivos existem - verificando timestamp...');
        
        if (fs.existsSync(LAST_CHECK_FILE)) {
            const lastCheckData = fs.readFileSync(LAST_CHECK_FILE, 'utf-8');
            const lastCheck = JSON.parse(lastCheckData).lastCheck;
            const now = moment().tz(TIMEZONE);
            const lastCheckMoment = moment.tz(lastCheck, TIMEZONE);
            const hoursSinceLastCheck = now.diff(lastCheckMoment, 'hours');
            
            console.log(`‚è∞ [FALLBACK] √öltima verifica√ß√£o: ${lastCheckMoment.format('DD/MM/YYYY HH:mm:ss')} (${hoursSinceLastCheck}h atr√°s)`);
            
            const needsUpdate = shouldUpdateNow(lastCheckMoment, now, scheduleMode);
            
            if (needsUpdate.shouldUpdate) {
                console.log(`üîÑ [FALLBACK] ${needsUpdate.reason} - iniciando atualiza√ß√£o...`);
                fetchAndSaveBundles();
            } else {
                console.log(`‚úÖ [FALLBACK] ${needsUpdate.reason}`);
            }
        } else {
            console.log('üìù [FALLBACK] Timestamp n√£o encontrado - iniciando verifica√ß√£o...');
            fetchAndSaveBundles();
        }
    }
};

console.log(`üïê Configura√ß√£o de agendamento: ${scheduleMode}`);
console.log(`üìÖ Cron: ${cronExpression} (${getScheduleDescription(scheduleMode)})`);

// Fun√ß√£o para descrever o agendamento
function getScheduleDescription(mode) {
    const descriptions = {
        OPTIMIZED: 'Quartas e sextas √†s 3h (ap√≥s atualiza√ß√µes da Steam)',
        DAILY: 'Todos os dias √†s 3h',
        WEEKLY: 'Apenas quartas √†s 3h'
    };
    return descriptions[mode] || descriptions.OPTIMIZED;
}

// Agenda a execu√ß√£o autom√°tica
cron.schedule(cronExpression, () => {
    console.log(`üîÑ [CRON] Iniciando atualiza√ß√£o autom√°tica agendada (${scheduleMode})`);
    console.log(`‚è∞ Hor√°rio: ${moment().tz(TIMEZONE).format('DD/MM/YYYY HH:mm:ss')}`);
    fetchAndSaveBundles();
}, {
    timezone: TIMEZONE
});

console.log(`‚úÖ Agendamento ativo: ${getScheduleDescription(scheduleMode)}`);

// Aguarda um pouco antes da verifica√ß√£o para dar tempo do database processar dados recentes
setTimeout(async () => {
    await checkLastVerification();
    
    checkAndResumeUpdate().then(hasIncompleteUpdate => {
        if (hasIncompleteUpdate) {
            console.log('üìã Sistema pronto para continuar atualiza√ß√£o incompleta');
        }
    }).catch(error => {
        console.error('‚ùå Erro ao verificar atualiza√ß√£o incompleta:', error.message);
    });
}, 3000); // 3 segundos de delay

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Servidor rodando na porta ${PORT}`);
});
