const express = require('express');
const helmet = require('helmet');
const compression = require('compression');
const cors = require('cors');
const cron = require('node-cron');
const moment = require('moment-timezone');
const fs = require('fs');

const { fetchAndSaveBundles } = require('./services/fetchBundles');
const { updateBundlesWithDetails, checkAndResumeUpdate } = require('./services/updateBundles');
const updateController = require('./services/updateController'); // Importa para ativar auto-resume
const routes = require('./routes');
const { requestLogger, corsOptions } = require('./middleware/security');
const { healthCheck, errorHandler, notFoundHandler } = require('./middleware/monitoring');
const { publicRateLimit } = require('./middleware/auth');

const app = express();

app.set('trust proxy', 1);

app.use(helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'"],
            scriptSrc: ["'self'"],
            imgSrc: ["'self'", "data:", "https:"],
        },
    },
    hsts: {
        maxAge: 31536000,
        includeSubDomains: true,
        preload: true
    }
}));

app.use(compression());
app.use(cors(corsOptions));
app.use(express.json({ limit: '10mb' }));
app.use(requestLogger);
app.use(publicRateLimit);

app.get('/health', healthCheck);
app.use('/', routes);
app.use(notFoundHandler);
app.use(errorHandler);

const LAST_CHECK_FILE = 'last_check.json';
const BUNDLES_FILE = 'bundles.json';
const BUNDLES_DETAILED_FILE = 'bundleDetailed.json';
const TIMEZONE = process.env.TIMEZONE || 'America/Sao_Paulo';

// Configura√ß√£o de hor√°rios para execu√ß√£o autom√°tica
const STEAM_UPDATE_SCHEDULE = {
    // Modo otimizado: apenas nos dias que a Steam atualiza (padr√£o)
    OPTIMIZED: '0 3 * * 3,5', // 3h da manh√£ nas quartas e sextas (ap√≥s atualiza√ß√µes da Steam)
    
    // Modo di√°rio: todas as madrugadas (se necess√°rio maior frequ√™ncia)
    DAILY: '0 3 * * *', // 3h da manh√£ todos os dias
    
    // Modo conservador: apenas uma vez por semana
    WEEKLY: '0 3 * * 3' // 3h da manh√£ apenas nas quartas
};

// Escolha o modo baseado na vari√°vel de ambiente
const scheduleMode = process.env.UPDATE_SCHEDULE_MODE || 'OPTIMIZED';
const cronExpression = STEAM_UPDATE_SCHEDULE[scheduleMode] || STEAM_UPDATE_SCHEDULE.OPTIMIZED;

// Fun√ß√µes auxiliares para status e agendamento (agora com acesso √†s constantes)
function getNextScheduledUpdate() {
    const now = moment().tz(TIMEZONE);
    const nextRun = getNextCronExecution(cronExpression, now);
    return nextRun.format('DD/MM/YYYY HH:mm:ss');
}

function getNextCronExecution(cronExpr, fromTime) {
    const [minute, hour, day, month, dayOfWeek] = cronExpr.split(' ');
    let next = fromTime.clone().add(1, 'day').startOf('day').hour(parseInt(hour)).minute(parseInt(minute));
    
    if (dayOfWeek !== '*') {
        const targetDays = dayOfWeek.split(',').map(d => parseInt(d));
        while (!targetDays.includes(next.day())) {
            next.add(1, 'day');
        }
        next.hour(parseInt(hour)).minute(parseInt(minute));
    }
    
    return next;
}

// Torna as fun√ß√µes dispon√≠veis globalmente para uso em routes.js
global.getNextScheduledUpdate = getNextScheduledUpdate;
global.getNextCronExecution = getNextCronExecution;

const checkLastVerification = () => {
    console.log('üîç Verificando status dos arquivos de bundles...');
    const bundlesExists = fs.existsSync(BUNDLES_FILE);
    const bundlesDetailedExists = fs.existsSync(BUNDLES_DETAILED_FILE);
    console.log(`üìã bundles.json: ${bundlesExists ? '‚úÖ Existe' : '‚ùå N√£o encontrado'}`);
    console.log(`üìÑ bundleDetailed.json: ${bundlesDetailedExists ? '‚úÖ Existe' : '‚ùå N√£o encontrado'}`);
    
    // --- NOVA L√ìGICA DE VERIFICA√á√ÉO INTELIGENTE ---
    if (!bundlesExists && !bundlesDetailedExists) {
        console.log('üö® Ambos os arquivos ausentes - iniciando coleta completa do in√≠cio...');
        fetchAndSaveBundles();
        return;
    }
    
    if (bundlesExists && !bundlesDetailedExists) {
        console.log('üîç bundles.json existe, mas bundleDetailed.json n√£o. Verificando integridade...');
        try {
            const bundlesData = JSON.parse(fs.readFileSync(BUNDLES_FILE, 'utf-8'));
            
            // Verifica se o arquivo bundles.json est√° completo
            if (!bundlesData.bundles || !Array.isArray(bundlesData.bundles) || bundlesData.bundles.length === 0) {
                console.log('‚ö†Ô∏è bundles.json existe mas est√° vazio ou corrompido - reiniciando coleta completa...');
                fetchAndSaveBundles();
                return;
            }
            
            // Verifica se tem a estrutura m√≠nima esperada
            const hasValidStructure = bundlesData.bundles.every(bundle => 
                bundle.Link && typeof bundle.Link === 'string' && bundle.Link.includes('/bundle/')
            );
            
            if (!hasValidStructure) {
                console.log('‚ö†Ô∏è bundles.json existe mas tem estrutura inv√°lida - reiniciando coleta completa...');
                fetchAndSaveBundles();
                return;
            }
            
            console.log(`‚úÖ bundles.json est√° √≠ntegro (${bundlesData.bundles.length} bundles)`);
            console.log('üöÄ bundleDetailed.json ausente - iniciando apenas atualiza√ß√£o detalhada...');
            
            // Executa apenas a atualiza√ß√£o detalhada via updateController
            setTimeout(() => {
                updateController.executeControlledUpdate(
                    () => updateBundlesWithDetails('brazilian'), 
                    'missing-detailed-file'
                ).catch(error => {
                    console.error('‚ùå Erro ao executar atualiza√ß√£o detalhada:', error.message);
                });
            }, 2000);
            return;
            
        } catch (error) {
            console.log('‚ö†Ô∏è Erro ao ler bundles.json - reiniciando coleta completa...', error.message);
            fetchAndSaveBundles();
            return;
        }
    }
    
    if (!bundlesExists && bundlesDetailedExists) {
        console.log('‚ö†Ô∏è bundleDetailed.json existe mas bundles.json n√£o - situa√ß√£o inconsistente');
        console.log('üö® Reiniciando coleta completa para garantir consist√™ncia...');
        fetchAndSaveBundles();
        return;
    }
    
    // Se ambos existem, faz a verifica√ß√£o de tempo com base no modo de agendamento
    if (bundlesExists && bundlesDetailedExists) {
        console.log('‚úÖ Ambos os arquivos existem - verificando timestamp...');
        
        if (fs.existsSync(LAST_CHECK_FILE)) {
            const lastCheckData = fs.readFileSync(LAST_CHECK_FILE, 'utf-8');
            const lastCheck = JSON.parse(lastCheckData).lastCheck;
            const now = moment().tz(TIMEZONE);
            const lastCheckMoment = moment.tz(lastCheck, TIMEZONE);
            const hoursSinceLastCheck = now.diff(lastCheckMoment, 'hours');
            
            console.log(`‚è∞ √öltima verifica√ß√£o: ${lastCheckMoment.format('DD/MM/YYYY HH:mm:ss')} (${hoursSinceLastCheck}h atr√°s)`);
            
            // Determina se precisa atualizar baseado no modo e hor√°rio
            const needsUpdate = shouldUpdateNow(lastCheckMoment, now, scheduleMode);
            
            if (needsUpdate.shouldUpdate) {
                console.log(`üîÑ ${needsUpdate.reason} - iniciando atualiza√ß√£o...`);
                fetchAndSaveBundles();
            } else {
                console.log(`‚úÖ ${needsUpdate.reason}`);
                console.log(`üìÖ Pr√≥xima atualiza√ß√£o agendada: ${getNextScheduledUpdate()}`);
            }
        } else {
            console.log('üìù Arquivo de timestamp n√£o encontrado - iniciando verifica√ß√£o inicial...');
            fetchAndSaveBundles();
        }
    }
};

// Fun√ß√£o para determinar se deve atualizar agora
function shouldUpdateNow(lastCheck, now, mode) {
    const hoursSince = now.diff(lastCheck, 'hours');
    const daysSince = now.diff(lastCheck, 'days');
    
    // Se passou mais de 7 dias, sempre atualiza independente do modo
    if (daysSince >= 7) {
        return { shouldUpdate: true, reason: 'Mais de 7 dias desde a √∫ltima verifica√ß√£o' };
    }
    
    // Se passou mais de 3 dias e n√£o √© modo conservador, atualiza
    if (daysSince >= 3 && mode !== 'WEEKLY') {
        return { shouldUpdate: true, reason: 'Mais de 3 dias desde a √∫ltima verifica√ß√£o' };
    }
    
    // Se passou mais de 24h e √© modo di√°rio, atualiza
    if (hoursSince >= 24 && mode === 'DAILY') {
        return { shouldUpdate: true, reason: 'Modo di√°rio: mais de 24h desde a √∫ltima verifica√ß√£o' };
    }
    
    // Se √© primeira execu√ß√£o do dia ap√≥s um dia de atualiza√ß√£o da Steam
    const today = now.day(); // 0=Dom, 1=Seg, 2=Ter, 3=Qua, 4=Qui, 5=Sex, 6=S√°b
    const yesterday = now.clone().subtract(1, 'day').day();
    
    if ((today === 3 || today === 5) && hoursSince >= 12) { // Qua ou Sex, e passou 12h
        const lastWasBeforeSteamUpdate = lastCheck.day() !== today;
        if (lastWasBeforeSteamUpdate) {
            return { shouldUpdate: true, reason: `Dia p√≥s-atualiza√ß√£o da Steam (${today === 3 ? 'Quarta' : 'Sexta'})` };
        }
    }
    
    return { 
        shouldUpdate: false, 
        reason: `Dados atualizados - pr√≥xima verifica√ß√£o conforme agendamento (${mode})` 
    };
}

console.log(`üïê Configura√ß√£o de agendamento: ${scheduleMode}`);
console.log(`üìÖ Cron: ${cronExpression} (${getScheduleDescription(scheduleMode)})`);

// Fun√ß√£o para descrever o agendamento
function getScheduleDescription(mode) {
    const descriptions = {
        OPTIMIZED: 'Quartas e sextas √†s 3h (ap√≥s atualiza√ß√µes da Steam)',
        DAILY: 'Todos os dias √†s 3h',
        WEEKLY: 'Apenas quartas √†s 3h'
    };
    return descriptions[mode] || descriptions.OPTIMIZED;
}

// Agenda a execu√ß√£o autom√°tica
cron.schedule(cronExpression, () => {
    console.log(`üîÑ [CRON] Iniciando atualiza√ß√£o autom√°tica agendada (${scheduleMode})`);
    console.log(`‚è∞ Hor√°rio: ${moment().tz(TIMEZONE).format('DD/MM/YYYY HH:mm:ss')}`);
    fetchAndSaveBundles();
}, {
    timezone: TIMEZONE
});

console.log(`‚úÖ Agendamento ativo: ${getScheduleDescription(scheduleMode)}`);

checkLastVerification();

checkAndResumeUpdate().then(hasIncompleteUpdate => {
    if (hasIncompleteUpdate) {
        console.log('üìã Sistema pronto para continuar atualiza√ß√£o incompleta');
    }
}).catch(error => {
    console.error('‚ùå Erro ao verificar atualiza√ß√£o incompleta:', error.message);
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Servidor rodando na porta ${PORT}`);
});
