// test-pre-deploy.js - Rotina de teste completa antes do deploy no Render
require('dotenv').config();

const { updateBundlesWithDetails, processFailedBundles } = require('./services/updateBundles');
const { fetchBundles } = require('./services/fetchBundles');
const { storageSyncManager } = require('./services/storageSync');
const fs = require('fs');

async function runPreDeployTests() {
    console.log('üß™ ROTINA DE TESTE PR√â-DEPLOY - Steam Bundle API\n');
    console.log('üéØ Objetivo: Validar sistema completo antes do deploy no Render');
    console.log('üìä Escopo: Fetch + Update + Storage API + Retry System\n');
    
    const testResults = {
        fetch: { success: false, error: null, bundles: 0 },
        storageConnection: { success: false, error: null },
        update: { success: false, error: null, processed: 0 },
        retry: { success: false, error: null, recovered: 0 },
        overall: { success: false, duration: 0 }
    };
    
    const startTime = Date.now();
    
    try {
        // ========================================
        // 1. TESTE DE FETCH LIMITADO (5 BUNDLES)
        // ========================================
        console.log('1Ô∏è‚É£ TESTE: Fetch de bundles b√°sicos (limitado a 5)...');
        try {
            const fetchResult = await fetchBundles(5); // Limita a 5 bundles
            
            if (fetchResult.success && fetchResult.totalBundles > 0) {
                testResults.fetch.success = true;
                testResults.fetch.bundles = fetchResult.totalBundles;
                console.log(`‚úÖ Fetch bem-sucedido: ${fetchResult.totalBundles} bundles obtidos`);
                console.log(`üìä Primeira p√°gina Steam: OK | Parsing: OK | Salvamento: OK`);
            } else {
                throw new Error(`Fetch falhou: ${fetchResult.error || 'Nenhum bundle encontrado'}`);
            }
        } catch (fetchError) {
            testResults.fetch.error = fetchError.message;
            console.log(`‚ùå Fetch falhou: ${fetchError.message}`);
            throw new Error(`BLOQUEADOR: Fetch b√°sico n√£o funciona`);
        }
        
        // ========================================
        // 2. TESTE DE CONEX√ÉO STORAGE API
        // ========================================
        console.log('\n2Ô∏è‚É£ TESTE: Conectividade Storage API...');
        try {
            storageSyncManager.validateConfig();
            const connectTest = await storageSyncManager.testConnection();
            
            if (connectTest.success) {
                testResults.storageConnection.success = true;
                console.log(`‚úÖ Storage API conectado: ${connectTest.status} (${connectTest.latency}ms)`);
            } else {
                throw new Error(`Conex√£o falhou: ${connectTest.error}`);
            }
        } catch (storageError) {
            testResults.storageConnection.error = storageError.message;
            console.log(`‚ùå Storage API falhou: ${storageError.message}`);
            console.log(`‚ö†Ô∏è AVISO: Deploy pode falhar sem Storage API`);
        }
        
        // ========================================
        // 3. TESTE DE UPDATE LIMITADO (3 BUNDLES)
        // ========================================
        console.log('\n3Ô∏è‚É£ TESTE: Update de bundles detalhados (limitado a 3)...');
        console.log('‚è∞ Timeout configurado: 2 minutos para seguran√ßa');
        
        try {
            // Timeout de seguran√ßa de 2 minutos
            const updatePromise = updateBundlesWithDetails('brazilian', 3); // Limita a 3 bundles
            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('TIMEOUT: Update demorou mais de 2 minutos')), 120000)
            );
            
            const updateResult = await Promise.race([updatePromise, timeoutPromise]);
            
            if (updateResult.success && updateResult.totalBundles > 0) {
                testResults.update.success = true;
                testResults.update.processed = updateResult.totalBundles;
                console.log(`‚úÖ Update bem-sucedido: ${updateResult.totalBundles} bundles processados`);
                
                if (updateResult.retryStats) {
                    console.log(`üìä Retry autom√°tico: ${updateResult.retryStats.processed} processados, ${updateResult.retryStats.recovered} recuperados`);
                }
                
                // Verifica se arquivo foi criado
                if (fs.existsSync('./bundleDetailed_test.json')) {
                    console.log(`üìÅ Arquivo teste criado: bundleDetailed_test.json`);
                } else {
                    console.log(`üìÅ Arquivo teste n√£o encontrado (pode ter sido sincronizado apenas)`);
                }
                
            } else {
                throw new Error(`Update falhou: ${updateResult.error || 'Nenhum bundle processado'}`);
            }
        } catch (updateError) {
            testResults.update.error = updateError.message;
            console.log(`‚ùå Update falhou: ${updateError.message}`);
            console.log(`‚ö†Ô∏è PROBLEMA: Sistema de scraping pode estar comprometido`);
        }
        
        // ========================================
        // 4. TESTE DE SISTEMA DE RETRY
        // ========================================
        console.log('\n4Ô∏è‚É£ TESTE: Sistema de retry...');
        try {
            const retryResult = await processFailedBundles();
            
            testResults.retry.success = true;
            testResults.retry.recovered = retryResult.recovered || 0;
            
            if (retryResult.processed > 0) {
                console.log(`‚úÖ Retry processado: ${retryResult.processed} bundles, ${retryResult.recovered} recuperados`);
            } else {
                console.log(`‚úÖ Sistema de retry OK: Nenhum bundle para retry (esperado em teste)`);
            }
        } catch (retryError) {
            testResults.retry.error = retryError.message;
            console.log(`‚ùå Retry falhou: ${retryError.message}`);
        }
        
        // ========================================
        // 5. TESTE DE SINCRONIZA√á√ÉO STORAGE
        // ========================================
        if (testResults.storageConnection.success) {
            console.log('\n5Ô∏è‚É£ TESTE: Sincroniza√ß√£o com Storage API...');
            try {
                // Testa sync de dados fict√≠cios
                const testSyncData = {
                    timestamp: new Date().toISOString(),
                    totalFailed: 0,
                    retryable: 0,
                    bundles: []
                };
                
                await storageSyncManager.syncFailedBundlesQueue(testSyncData);
                console.log(`‚úÖ Sincroniza√ß√£o teste bem-sucedida`);
                
                // Testa recupera√ß√£o
                const recoverResult = await storageSyncManager.getFailedBundlesQueue();
                if (recoverResult.success) {
                    console.log(`‚úÖ Recupera√ß√£o de dados bem-sucedida`);
                } else {
                    console.log(`‚ö†Ô∏è Recupera√ß√£o falhou: ${recoverResult.error}`);
                }
                
            } catch (syncError) {
                console.log(`‚ùå Sincroniza√ß√£o falhou: ${syncError.message}`);
            }
        }
        
        // ========================================
        // RESULTADOS FINAIS
        // ========================================
        const duration = (Date.now() - startTime) / 1000;
        testResults.overall.duration = duration;
        
        const allCriticalTestsPassed = testResults.fetch.success && 
                                     testResults.update.success;
        
        testResults.overall.success = allCriticalTestsPassed;
        
        console.log('\n' + '='.repeat(60));
        console.log('üèÅ RESULTADOS FINAIS DOS TESTES PR√â-DEPLOY');
        console.log('='.repeat(60));
        
        console.log(`‚è±Ô∏è  Dura√ß√£o total: ${duration.toFixed(1)}s\n`);
        
        console.log('üìä RESULTADOS POR COMPONENTE:');
        console.log(`   1Ô∏è‚É£ Fetch Bundles: ${testResults.fetch.success ? '‚úÖ' : '‚ùå'} (${testResults.fetch.bundles} bundles)`);
        console.log(`   2Ô∏è‚É£ Storage API: ${testResults.storageConnection.success ? '‚úÖ' : '‚ùå'}`);
        console.log(`   3Ô∏è‚É£ Update Scraping: ${testResults.update.success ? '‚úÖ' : '‚ùå'} (${testResults.update.processed} processados)`);
        console.log(`   4Ô∏è‚É£ Retry System: ${testResults.retry.success ? '‚úÖ' : '‚ùå'} (${testResults.retry.recovered} recuperados)`);
        
        if (allCriticalTestsPassed) {
            console.log('\nüéâ TODOS OS TESTES CR√çTICOS PASSARAM!');
            console.log('‚úÖ Sistema pronto para deploy no Render');
            console.log('\nüìã CHECKLIST PR√â-DEPLOY:');
            console.log('   ‚úÖ Fetch de bundles funcionando');
            console.log('   ‚úÖ Scraping de detalhes funcionando');
            console.log('   ‚úÖ Sistema de retry funcionando');
            console.log(`   ${testResults.storageConnection.success ? '‚úÖ' : '‚ö†Ô∏è'} Storage API ${testResults.storageConnection.success ? 'funcionando' : 'com problemas'}`);
            console.log('\nüöÄ RECOMENDA√á√ÉO: PROSSEGUIR COM DEPLOY');
            
            if (!testResults.storageConnection.success) {
                console.log('\n‚ö†Ô∏è ATEN√á√ÉO: Storage API com problemas');
                console.log('   üìù Verificar vari√°veis de ambiente no Render');
                console.log('   üìù Confirmar URLs e chaves de API');
            }
            
        } else {
            console.log('\n‚ùå ALGUNS TESTES CR√çTICOS FALHARAM!');
            console.log('üõë RECOMENDA√á√ÉO: CORRIGIR PROBLEMAS ANTES DO DEPLOY');
            console.log('\nüîç PROBLEMAS ENCONTRADOS:');
            
            if (!testResults.fetch.success) {
                console.log(`   ‚ùå Fetch: ${testResults.fetch.error}`);
            }
            if (!testResults.update.success) {
                console.log(`   ‚ùå Update: ${testResults.update.error}`);
            }
        }
        
    } catch (criticalError) {
        testResults.overall.success = false;
        console.log('\nüí• ERRO CR√çTICO DURANTE TESTES:');
        console.log(`‚ùå ${criticalError.message}`);
        console.log('\nüõë DEPLOY BLOQUEADO - CORRIGIR ERRO CR√çTICO');
    }
    
    // Salva relat√≥rio de teste
    const reportPath = './test-pre-deploy-report.json';
    const report = {
        timestamp: new Date().toISOString(),
        duration: testResults.overall.duration,
        success: testResults.overall.success,
        environment: {
            NODE_ENV: process.env.NODE_ENV || 'development',
            STORAGE_API_URL: process.env.STORAGE_API_URL || 'not set',
            hasStorageKey: !!process.env.STORAGE_API_KEY
        },
        results: testResults
    };
    
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
    console.log(`\nüìÑ Relat√≥rio salvo: ${reportPath}`);
    
    return testResults.overall.success;
}

// Executa os testes
if (require.main === module) {
    runPreDeployTests()
        .then(success => {
            process.exit(success ? 0 : 1);
        })
        .catch(error => {
            console.error('üí• Erro fatal nos testes:', error);
            process.exit(1);
        });
}

module.exports = { runPreDeployTests };
